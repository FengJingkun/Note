## 重传机制

TCP通过序列号和确认应答实现可靠性传输。针对数据包丢失的情况，TCP会用重传机制解决。

### 超时重传

发送数据时设置一个定时器，超过指定时间仍未收到ACK报文，则重发该数据。

若TCP数据包丢失，或者ACK报文丢失，则触发超时重传机制。

**超时时间RTO(Retransmission TimeOut)的设置**

往返时延RTT(Round-Trip Time)是数据在两端往返的时间，**RTO应该略大于RTT**。

- RTO过大时，过长的重传时间导致效率低下；
- RTO过小时，可能在未丢失的情况下就进行重发，会增加网络堵塞，进而导致更多的超时和重发。

**RTO是一个动态变化的值，要估计RTO时间，需要采样RTT的值并进行加权平均，同时还要采样RTT的波动范围。**

<br>

### 快速重传

发送端连续收到三个确认号相同的ACK报文，则在定时器过期前，立即重传对应序号的报文。

**重传报文时，是重传单个报文，还是重传该报文之后的所有报文？**

<br>

### SACK

为了解决不知道该重传哪些报文，引入了SACK( Selective Ackonwledgement 选择确认 )重传机制。

**接收端在TCP首部的可选字段添加SACK选项，并填入当前已缓存的报文序号。发送端据此确定重发哪些报文。**

通信双方必须全部支持SACK，可通过内核参数**net.ipv4.tcp_sack**打开该功能。

<br>

### Duplicate-SACK

接收端使用SACK选项告诉发送端收到了哪些重复报文。

**ACK报文丢失**

发送端未接收到ACK，超时重传相应数据包X；接收端发现收到重复的数据包，于是在ACK报文首部添加SACK选项，填入重复报文序号X，并在ACK填入下一个期望接收的报文号。

发送端收到ACK报文，发现ACK号覆盖了SACK序号X，从而发现自己发送了重复报文。

**数据包延迟**

发送端收到连续三个相同的ACK，触发快速重传。当被延迟的数据包到达接收端时，接收端同样触发D-SACK。此时发送端就能够知道当前网络存在延迟。

因此，使用D-SACK可以：

- 让发送端知道是ACK丢失还是数据包丢失；
- 让发送端知道数据包是否被网络延迟；
- 网络是否复制了发送端的数据包。

<br>

<br>

## 滑动窗口

TCP以段为单位，每发一个段进行一次确认应答，收到ACK后才进行下一个段的传输。包的往返时间越长，通信效率越低。为了解决该问题，TCP引入了窗口。**确认应答不再是以分段，而是以更大的单位进行确认，即窗口。**

**窗口大小是指无需等待ACK而可以继续发送数据的最大值。**

OS开辟一块缓存空间作为窗口的实现，发送端在缓冲区保存已发送数据，若按期收到ACK，则清除缓存区。

**接收端通过TCP首部的窗口字段告知自己还有多少缓冲区可以接收数据，发送端根据该字段来决定自己的窗口大小。**

<br>

### 发送端的滑动窗口

发送端的滑动窗口不能超过接收端的窗口大小，否则接收方无法正常接收数据。假设滑动窗口大小为3个TCP段：

- 发送端连续发送3个TCP段，可用窗口的大小为0，此时发送端无法继续发送数据；
- 发送端收到第一个TCP段的ACK后，如果此时窗口大小未发生变化，则向右移动一个TCP段的距离，此时可用窗口的大小变为1，发送端可以继续发送数据。
- 若第二个TCP段的ACK丢失，发送端收到第三个TCP段的ACK，则认为这三个TCP段均被接收，即**累计应答**。

滑动窗口可将传输数据可分为四部分，即：

**已发送且收到ACK的数据，[ 已发送未收到ACK的数据，处于窗口内的未发送数据 ]，处于窗口外的未发送数据。**

特别地，**程序通过三个指针来区分这四部分，其中两个为绝对指针，一个为相对指针。**

- SND.WND：表示发送窗口的大小；
- SND.UNA：绝对指针，指向当前窗口的左边界；
- SND.NXT：绝对指针，指向未发送但处于窗口内的第一个字节的序列号；
- SND.UNA + SND.WND：相对指针，指向当前窗口的右边界。

此时可用窗口的大小 = SND.UNA + SND.WND - SND.NXT

<br>

### 接收端的滑动窗口

接收端窗口将数据划分为三部分，即：

**已接收并确认的数据，[ 未收到但处于窗口内的可接收数据 ]，超出接收能力范围的未接收数据。**

**程序通过两个指针来区分这三部分。**

- RCV.WND：表示接收窗口的大小
- RCV.NXT：绝对指针，指向当前窗口的左边界，表示当前可接收的下一个字节序号
- RCV.NXT + RCV.WND：相对指针，指向当前窗口的右边界。

<br>

<br>

## 流量控制

TCP通过滑动窗口实现流量控制。特别地，发送窗口和接收窗口中的数据实际上存放在了OS的缓冲区，**缓冲区的大小由OS进行调整。**

**服务器繁忙，未及时读取缓冲区数据时**

客户端为发送方，服务端为接收方，初始窗口大小为300。此时服务端繁忙，应用层不能及时读取缓冲区数据。

若客户端发送200字节的数据，发送窗口的可用大小变为100；但是服务端应用层仅读取了80字节的数据，剩余120字节在缓冲区内，于是**接收窗口缩小为180字节**，发送ACK时将当前的窗口大小告知客户端，客户端随后将发送窗口减小为180。当窗口大小紧缩为0时，就发生了**窗口关闭。**

**若服务端资源非常紧张，OS可能直接减少缓冲区大小，而应用层无法及时读取缓存数据，此时就会导致数据包丢失。**

客户端发送110字节数据，可用窗口变为190；服务端OS将缓冲区减小了90字节，并且由于应用层没有读取任何数据，所以110字节的数据被存放在缓冲区，此时接收窗口紧缩为300 - 110 - 90 = 100字节。**窗口内的数据可以在未收到ACK报文前持续发送，此时客户端又发送了150字节的数据，可用窗口变为40。**

- 服务端收到这150字节的数据，发现超过了接收窗口的大小，**于是将这些数据丢弃。**

- 客户端收到110字节数据的ACK报文，滑动窗口整体右移110字节，可用窗口大小为150；此时根据ACK将滑动窗口紧缩为100字节，即窗口右边界左移300 - 100 = 200字节。**由于上次发送了150字节的数据，所以此时可用窗口的大小就变成了-50！**

**为了防止这些现象发生，TCP规定不允许减小缓存的同时收缩窗口，而是采用先紧缩窗口，过段时间再减少缓存的方法，这样就避免了丢包情况。**

<br>

### 窗口关闭

发生窗口关闭时，发送方不再发送数据，直至接收窗口不再为0为止。当接收方处理完数据，可用窗口不再为0，则向发送方发送一个窗口非0的ACK报文。**若该报文丢失，则双方会陷入持续等待状态，即死锁。**

为了解决该问题，TCP为每一个连接设有一个持续定时器，**只要连接一方收到对方的0窗口报文，就启动定时器。**

定时器超时后，发送**窗口探测报文**，对方收到该报文后在ACK报文中告知当前的窗口大小。

- 若窗口仍旧为0，则重启定时器
- 若窗口不为0，则可打破死锁局面。

<br>

### 糊涂窗口综合症

接收方无法及时读取缓冲区数据，导致窗口越来越小。若接收方某次仅读取了5个字节的数据，并告知发送方现在的可用窗口大小为5字节，那么发送方就会在下次发送时发送这5个字节。然而，TCP的首部为40字节，为了传输这5字节花费如此大的开销，则太不经济了。

为了解决该问题，可以从通信双方入手：

- **接收方：**设置一个窗口最小值min，当可用窗口小于min时，向发送方发送0窗口ACK报文；

- **发送方：**Nagle延时算法。

  ```c++
  // Nagle算法
  if (window_size >= MSS and data_size >= MSS)
      send data;
  else if (receive the ACK for the data sent before)
      send data;
  ```

<br>

<br>

## 拥塞控制

流量控制是为了避免发送方填满接收方的缓冲区；拥塞控制则是避免发送方的数据填满整个网络。

<br>

<br>