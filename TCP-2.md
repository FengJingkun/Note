## 重传机制

TCP通过序列号和确认应答实现可靠性传输。针对数据包丢失的情况，TCP会用重传机制解决。

### 超时重传

发送数据时设置一个定时器，超过指定时间仍未收到ACK报文，则重发该数据。

若TCP数据包丢失，或者ACK报文丢失，则触发超时重传机制。

**超时时间RTO(Retransmission TimeOut)的设置**

往返时延RTT(Round-Trip Time)是数据在两端往返的时间，**RTO应该略大于RTT**。

- RTO过大时，过长的重传时间导致效率低下；
- RTO过小时，可能在未丢失的情况下就进行重发，会增加网络堵塞，进而导致更多的超时和重发。

**RTO是一个动态变化的值，要估计RTO时间，需要采样RTT的值并进行加权平均，同时还要采样RTT的波动范围。**

<br>

### 快速重传

发送端连续收到三个确认号相同的ACK报文，则在定时器过期前，立即重传对应序号的报文。

**重传报文时，是重传单个报文，还是重传该报文之后的所有报文？**

<br>

### SACK

为了解决不知道该重传哪些报文，引入了SACK( Selective Ackonwledgement 选择确认 )重传机制。

**接收端在TCP首部的可选字段添加SACK选项，并填入当前已缓存的报文序号。发送端据此确定重发哪些报文。**

通信双方必须全部支持SACK，可通过内核参数**net.ipv4.tcp_sack**打开该功能。

<br>

### Duplicate-SACK

接收端使用SACK选项告诉发送端收到了哪些重复报文。

**ACK报文丢失**

发送端未接收到ACK，超时重传相应数据包X；接收端发现收到重复的数据包，于是在ACK报文首部添加SACK选项，填入重复报文序号X，并在ACK填入下一个期望接收的报文号。

发送端收到ACK报文，发现ACK号覆盖了SACK序号X，从而发现自己发送了重复报文。

**数据包延迟**

发送端收到连续三个相同的ACK，触发快速重传。当被延迟的数据包到达接收端时，接收端同样触发D-SACK。此时发送端就能够知道当前网络存在延迟。

因此，使用D-SACK可以：

- 让发送端知道是ACK丢失还是数据包丢失；
- 让发送端知道数据包是否被网络延迟；
- 网络是否复制了发送端的数据包。

<br>

<br>

## 滑动窗口

TCP以段为单位，每发一个段进行一次确认应答，收到ACK后才进行下一个段的传输。包的往返时间越长，通信效率越低。为了解决该问题，TCP引入了窗口。**确认应答不再是以分段，而是以更大的单位进行确认，即窗口。**

**窗口大小是指无需等待ACK而可以继续发送数据的最大值。**

OS开辟一块缓存空间作为窗口的实现，发送端在缓冲区保存已发送数据，若按期收到ACK，则清除缓存区。

**接收端通过TCP首部的窗口字段告知自己还有多少缓冲区可以接收数据，发送端根据该字段来决定自己的窗口大小。**

<br>

### 发送端的滑动窗口

发送端的滑动窗口不能超过接收端的窗口大小，否则接收方无法正常接收数据。假设滑动窗口大小为3个TCP段：

- 发送端连续发送3个TCP段，可用窗口的大小为0，此时发送端无法继续发送数据；
- 发送端收到第一个TCP段的ACK后，如果此时窗口大小未发生变化，则向右移动一个TCP段的距离，此时可用窗口的大小变为1，发送端可以继续发送数据。
- 若第二个TCP段的ACK丢失，发送端收到第三个TCP段的ACK，则认为这三个TCP段均被接收，即**累计应答**。

滑动窗口可将传输数据可分为四部分，即：

**已发送且收到ACK的数据，[ 已发送未收到ACK的数据，处于窗口内的未发送数据 ]，处于窗口外的未发送数据。**

特别地，**程序通过三个指针来区分这四部分，其中两个为绝对指针，一个为相对指针。**

- SND.WND：表示发送窗口的大小；
- SND.UNA：绝对指针，指向当前窗口的左边界；
- SND.NXT：绝对指针，指向未发送但处于窗口内的第一个字节的序列号；
- SND.UNA + SND.WND：相对指针，指向当前窗口的右边界。

此时可用窗口的大小 = SND.UNA + SND.WND - SND.NXT

<br>

### 接收端的滑动窗口

接收端窗口将数据划分为三部分，即：

**已接收并确认的数据，[ 未收到但处于窗口内的可接收数据 ]，超出接收能力范围的未接收数据。**

**程序通过两个指针来区分这三部分。**

- RCV.WND：表示接收窗口的大小
- RCV.NXT：绝对指针，指向当前窗口的左边界，表示当前可接收的下一个字节序号
- RCV.NXT + RCV.WND：相对指针，指向当前窗口的右边界。

<br>

<br>

## 流量控制

TCP通过滑动窗口实现流量控制。

<br>

<br>

## 拥塞控制

<br>

<br>