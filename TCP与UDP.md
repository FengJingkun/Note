链路层存在MAC地址，用于识别同一链路中的不同计算机。

网络层存在IP地址，用于识别TCP/IP网络中互联的主机和路由器。此外，IP首部有一个协议字段，用来识别网络层的上一层所采用的协议。根据该字段来区分传输层使用的是TCP还是UDP协议。

传输层则存在端口号，用于识别同一台计算机中进行通信的不同应用程序。

**< 源IP，目的IP，源端口号，目的端口号，协议号 >用来识别一个通信。**

<br>

## 端口号

- **知名端口号**：HTTP，FTP等广泛应用的应用协议使用的端口号都是固定的，一般为0~1023。
- **时序分配**：每需要一个端口号，OS在之前分配号码的基础上加1。

**不同的传输协议可以使用相同的端口号。**数据到达网络层后，根据IP首部的协议号传给不同的协议模块去处理，即使端口号相同，处理过程也是独立的，相互之间不会受到影响。

<br>

## TCP

TCP是面向连接的，可靠的，基于字节流的传输协议。

- 面向连接：一对一连接
- 可靠：无论网络链路怎么变化，TCP都能保证数据能到达接收端
- 字节流：无论发送数据有多大都可以进行传输。并且消息是有序的，当前一个字节未收到时，即使收到后续字节，也不会交给应用程序去处理。

**< 源IP，源端口，目的IP，目的端口 >可唯一确定一个TCP连接。**

<br>

### TCP的可靠性

**TCP通过序列号和确认号来保证可靠性：**

- 接收方可以根据SYN中的序列号去除重复数据
- 接收方可以根据数据包的序列号按序接收
- 发送方可以根据ACK中的序列号确认哪些数据已经被接收方接收

**发送端和接收端各维护一个初始序列号。**

发送端按顺序发送数据，并为数据的每个字节标上一个序列号；接收端查询TCP首部中的序列号，将自己下一次应该接收的序列号作为应答发回发送端。发送端接收到ACK，则认为该序列号之前的**所有数据**均已到达接收端。

**TCP首部并不包含数据长度**，但可以由下面的公式计算得到：

**TCP数据的长度 = IP总长度 - IP首部长度 - TCP首部长度**

<br>

### TCP的超时重传

发送端将数据发出后等待接收端的确认应答ACK。若在一定时间内未等到ACK，则发送端认为数据已丢失，并进行重传。

**超时重传的时间 > 数据包在两端往返一次的时间 + 偏差**

网络环境的变化会导致数据包的往返时间存在波动，因此在确定超时重传的时间上要考虑到波动带来的偏差。

数据重发后若仍然收不到ACK，则超时重传的时间会呈指数增长，达到一定重发次数后，则会断开TCP连接。

<br>

### TCP连接：三次握手

**为了保证可靠性和流量控制而维护的某些状态信息。这些信息的组合(Socket，序列号和窗口大小)被称为TCP连接。**

TCP是面向连接的协议，双方在使用TCP通信前必须通过三次握手建立连接。

- **客户端和服务端均处于Closed状态。服务端主动监听某个端口，处于Listen状态。**

**第一次握手**

客户端随机初始化序列号x，将x置于TCP首部的序号字段，并将SYN标志位置为1，表示SYN报文，该报文不包含将要发送的数据。

- **客户端发送第一个SYN报文，请求建立连接，然后处于Syn-Sent状态。**

**第二次握手**

服务端收到SYN报文后，首先随机初始化自己的序列号y，将y置于TCP首部的序号字段，并将SYN和ACK标志位置为1，同时把x + 1填入TCP首部的确认应答号字段。该报文同样不包含应用层数据。

- **服务端发送SYN + ACK报文，然后处于Syn-Rcvd状态。**

**第三次握手**

客户端收到SYN + ACK报文后，将y + 1填入TCP首部的确认应答号字段，并将x + 1填入TCP首部的序号字段，ACK标志位置1，发送针对SYN的ACK报文。**这次发送可以携带应用层数据。**

- **客户端发送针对服务端SYN的ACK报文，然后处于Established状态。**
- **服务端收到ACK报文，处于Established状态。**

至此，三次握手完成，双方开始相互发送数据。

<br>

**为什么是三次握手？**

- **阻止重复历史连接的初始化。**

> **客户端**发起SYN请求A，A在网络中阻塞；客户端等待超时后再次发送SYN请求B，此时A在B之前到达。**服务端**返回SYN+ACK至客户端；**后者**根据上下文判断这是一个历史连接，于是**第三次握手**发送RST报文中止连接。

- **同步双方的序列号**

> 序列号是TCP可靠传输的保证，因此建立连接时双方需要同步各自的序列号。第一次握手客户端发送初始序列号X给服务端；第二次握手服务端发出X的确认，并发送初始序列号Y给客户端；第三次握手客户端发出Y的确认。

- **避免资源浪费**

> 当客户端的SYN请求阻塞时，客户端会重发SYN请求。若没有三次握手，服务端无法确认自己的ACK是否到达，则只能没收到一个SYN请求就主动建立一个连接，从而出现多个冗余的无效连接，造成资源浪费。

<br>

### 初始序列号ISN

**ISN = Clock + Hash( SourcePort, DesPort, SourceIP, DesIP )**

其中，Clock是一个计时器，每隔4ms加1；Hash通常采用MD5算法来保证安全性。

**为什么每次建立连接都需要初始化序列号ISN？**

可以根据ISN判断历史连接。若某个失效连接被重启，但此时网络中还存在该连接的数据包，如果不重新初始化ISN，则当旧数据包到达时，就无法分辨该数据包是不是历史报文，从而造成数据紊乱。

此外，重新初始化ISN也可以防止黑客伪造的相同序列号的TCP报文被接收。

<br>

### TCP以段为单位发送数据

建立TCP连接的同时会确定发送数据包的单位，即**最大消息长度MSS( Maximum Segment Size )**。

**MSS：除去IP和TCP首部后，一个网络包能容纳的TCP数据的最大长度。**

三次握手时，客户端和服务端交换各自能够适应的MSS大小，然后取一个较小值使用。

**既然IP会分片，为什么TCP还需要MSS？**

IP层用MTU来表示一个网络包的最大长度，当IP层存在超过一个MTU大小的数据(TCP首部 + TCP数据)，就会被分片。然后由接收方的IP层进行重组并移交给传输层。

**由于IP层没有超时重传机制，因此需要通过传输层的TCP来负责超时和重传。**

若TCP不进行分段，某个IP分片丢失，则整个IP报文都需要重传。因此使用MSS可以减少不必要的IP分片。

<br>

### SYN攻击

伪造客户端向服务端发送SYN报文，服务端每接收一个SYN报文，就进入SYN_RCVD状态。但服务端发出的SYN + ACK报文无法得到对方应答，久而久之会占满服务端的SYN接收队列（未连接队列） ，导致服务端无法为正常访问提供服务。

**正常流程**

1. 服务端接收SYN报文后，将其加入到内核的**SYN队列**
2. 服务端发送SYN + ACK报文给客户端，等待回应；
3. 服务端接收到ACK报文后，从**SYN队列**移除连接并放入**Accept队列**；
4. 应用调用socket的accept接口，从**Accept队列**取出连接

当受到SYN攻击时，服务端的**SYN队列**被占满。

**解决办法**

1. 当**SYN队列**占满时，后续到来的SYN包，不再进入**SYN队列**；
2. 计算出一个cookie值，填入首部序列号字段后返回SYN + ACK报文；
3. 收到客户端的ACK报文时，根据序列号验证该报文的合法性，若合法，直接放入**Accept队列**

<br>

### TCP断开连接：四次挥手

**客户端和服务端都可以主动断开连接。**

客户端和服务端都处于Established状态；

- 客户端准备关闭连接，发送TCP首部FIN标志位置1的报文，即FIN报文，进入**FIN_Wait_1**状态；

- 服务端收到FIN报文，回应ACK报文，进入**Closed_Wait**状态；

客户端收到服务端的ACK报文，进入**FIN_Wait_2**状态；

- 服务端处理完数据后，也向客户端发送FIN报文，进入**Last_ACK**状态；

- 客户端收到FIN报文，回应ACK报文，进入**Time_Wait**状态；

服务端收到ACK报文，进入**Closed**状态，至此**服务端到客户端的连接被关闭**；

客户端等待2MSL后，自动进入**Closed**状态，至此**客户端到服务端的连接被关闭**。

<br>

**为什么需要4次挥手？**

客户端发送FIN报文请求关闭连接时，仅表示自己不再发送数据了，但还能接收数据。

服务端先回应ACK报文，此时可能还有数据需要处理和发送；等服务端也不再发送数据时，才发送FIN报文表示连接可以关闭了。

由于服务端需要等待完成数据的处理和发送，所以服务端的ACK和FIN需要分开发送，从而导致比三次握手多了一次。

<br>

### Time Wait状态

**只有主动关闭连接的一方才会进入Time wait状态。**

Time wait被设置为2MSL。其中，MSL是Maximum Segment Lifetime，**报文最大生存时间**。即报文在网络上的生存时间，超过这个时间报文将被丢弃。

若服务端未收到最后的ACK报文，则超时后会重传一个FIN报文；客户端收到FIN后重传ACK报文，并**重置2MSL的计时。**

将Time Wait设置为2MSL，一是由于网络中可能存在尚未到达服务端的数据包，当这些数据包到达服务端后，会被处理并发送ACK，这个时间刚好是2MSL。二是可以确保最后的ACK能被服务端接收。

**为什么需要Time Wait状态？**

- **防止具有相同四元组的旧数据包被收到**

> 服务端在关闭连接前发送的某个报文在网络中阻塞；若存在相同端口的TCP连接被复用，且time wait不存在或时间过短，则延迟到达的过期报文可能被客户端正常接收，从而造成数据紊乱。
>
> 引入Time Wait状态，并且等待2MSL，可以保证旧连接的所有数据包都被丢弃。 

- **保证最后的ACK能被接收，从而保证其正常关闭**

> 若客户端发送ACK后直接进入Closed状态，ACK丢失时，服务端会反复重传FIN并一直处于Last ACK状态。此时若客户端发起建立新连接的SYN报文，服务端会直接发送RST报文，中止新连接的建立。
>
> Time Wait等待2MSL，当ACK丢失时，服务端重传FIN，客户端收到后重传ACK，并重置2MSL计时，因此可以保证连接的正常关闭。

<br>

**Time Wait过多会有什么危害？**

若服务端存在处于Time Wait状态的连接，说明服务端是主动断开连接的一方。过多的Time Wait状态主要有两种危害：

- **内存资源占用**
- **端口资源的占用，一个TCP连接会至少消耗一个本地端口，从而导致无法建立新连接**

<br>

**如何优化Time Wait？**

- **修改内核参数**

> **打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项**
>
> 复用处于Time Wait的socket为新连接所用，仅适用于客户端。开启后，调用connect函数时，内核会随机寻找一个Time Wait超过1秒的连接给新连接复用。
>
> 时间戳位于TCP首部，用于记录发送方的当前时间戳和从对端接收到的最新时间戳。引入时间戳后，2MSL问题就不会存在了，因为旧数据包会因时间戳过期而被丢弃。

- **程序中使用SO_LINGER**

> **socket设置SO_LINGER选项，来设置调用close关闭连接时的行为**
>
> ```c++
> struct linger so_linger;
> so_linger.l_onoff = 1;
> so_linger.l_linger = 0;
> setsockopt(s, SOL_SOCKET, SO_LINGER, &so_linger, sizeof(so_linger));
> ```
>
> 此时调用close后会直接发送RST报文终止连接，即**跳过Time Wait状态**。

<br>

**如果已建立了连接，但客户端发生了故障怎么办？**

TCP有一个保活机制，即定义一个时间段，在该时间段内，如果没有任何连接相关的活动，则保活机制开始作用。每个一段时间发送一个探测报文，若连续几个报文没被响应，则认为当前TCP连接死亡。

**通过调整内核参数可以设置保活时间，保活的探测次数，保活探测的时间间隔。**

- 对端程序正常工作时：探测报文发送后得到正常响应，然后发送端**重置保活时间。**
- 对端程序崩溃并重启：对端程序收到探测报文后响应一个RST报文，然后发送端**断开连接。**
- 对端程序崩溃：发送探测报文后无响应，达到探测保活次数后**断开连接。**

<br>

<br>

## TCP Socket

### 连接流程

- 客户端和服务端初始化socket，得到文件描述符fd；
- 服务端调用bind绑定端口，并调用listen循环监听端口；
- 服务端调用accept并阻塞，等待客户端连接；
- 客户端调用connect，向服务端IP和端口发起连接请求；
- 服务端accept返回用于通信的socket fd。

服务端调用accept，完成三次握手建立连接后会返回一个已连接的socket文件描述符，后续用来传输数据。

**监听端口的socket和传输数据的socket并不是同一个，前者又叫监听socket，后者叫已完成连接socket。**

<br>

### listen函数

如前所述，Linux内核维护两个队列：

- **未完成连接队列(SYN队列)：**接收到SYN请求，处于SYN_RCVD状态；
- **已完成连接队列(Accept队列)：**完成TCP三次握手，处于Established状态

当第三次握手的ACK到达后，服务端将相应连接从SYN队列取出，并放入Accept队列。随后服务端应用程序调用accpet函数取出已完成连接的socket。

```c++
int listen(int socketfd, int backlog);
```

对于参数backlog，在内核2.2之前，backlog表示SYN队列的大小，现在则表示Accept队列的长度，其上限值是内核参数somaxconn的大小，因此**Accept队列的最大长度 = min(backlog, somaxconn)**。

<br>

**Connect和Accept发生在三次握手的哪一步？**

客户端收到第二次握手返回的SYN + ACK报文后，客户端到服务端的单向连接就已经建立了，客户端进入Established状态，**因此connect在此时返回。**

服务端收到第三次握手发送的ACK报文后进入Established状态，此时服务端到客户端的单向连接完成建立，**因此accept在此时返回。**

<br>

### 断开流程

- 传输数据时，客户端调用write写数据，服务端调用read读数据；
- 客户端断开连接时调用close，然后发送FIN报文，进入FIN_Wait_1状态；
- 服务端收到FIN报文，**TCP协议栈自动为FIN包插入一个文件结束符EOF到接收缓冲区**；
- 服务端通过read感知到FIN包，返回ACK报文，进入Close_Wait状态；客户端则收到ACK进入FIN_Wait_2状态；
- 服务端继续处理接收缓冲区内的数据，当处理到EOF时，调用close，发送FIN包并进入Last_ACK状态；
- 客户端收到FIN报文，返回ACK并进入Time_Wait状态；
- 服务端收到ACK报文，进入Close状态；客户端等待2MSL后进入Close状态。